[{"authors":["admin"],"categories":null,"content":"Gary Chen is an undergraduate student majored in computer engineering.\n\r Download my resumé.\n","date":1625285592,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1625285592,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://chen-gary.github.io/author/gary-chen/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/gary-chen/","section":"authors","summary":"Gary Chen is an undergraduate student majored in computer engineering.\n\r Download my resumé.","tags":null,"title":"Gary Chen","type":"authors"},{"authors":["Gary Chen"],"categories":null,"content":"这篇文章是对\r这份教程的笔记，虽说是笔记，很多地方都直接复制了原文，强烈建议大家进入原教程查看。\n（注：以下文档默认使用XeLaTeX进行编译）\n控制序列：\\开头，e.g. \\documentclass。以第一个空格或非字母 的字符结束\n注释：%\n\\documentclass{article}\r% 这里是导言区\r\\begin{document}\rHello, world!\r\\end{document}\r 控制序列begin和end总是成对出现。这两个控制序列以及他们中间的内容被称为「环境」，它们之后的第一个必要参数总是一致的，被称为环境名。\n只有在 document 环境中的内容，才会被正常输出到文档中去或是作为控制序列对文档产生影响。\n从 \\documentclass{article} 开始到 \\begin{document} 之前的部分被称为导言区。在导言区出现的控制序列，往往会影响整篇文档的格式。\n宏包：一系列控制序列的合集。\\usepackage{} 可以用来调用宏包\n中英文混排 \\documentclass[UTF8]{ctexart}\r\\begin{document}\r你好，world!\r\\end{document}\r 组织你的文章 作者、标题、日期 \\documentclass[UTF8]{ctexart}\r\\title{你好，world!}\r\\author{Liam}\r\\date{\\today}\r\\begin{document}\r\\maketitle\r你好，world!\r\\end{document}\r 章节和段落 \\documentclass[UTF8]{ctexart}\r\\title{你好，world!}\r\\author{Liam}\r\\date{\\today}\r\\begin{document}\r\\maketitle\r\\section{你好中国}\r中国在East Asia.\r\\subsection{Hello Beijing}\r北京是capital of China.\r\\subsubsection{Hello Dongcheng District}\r\\paragraph{Tian'anmen Square}\ris in the center of Beijing\r\\subparagraph{Chairman Mao}\ris in the center of 天安门广场。\r\\subsection{Hello 山东}\r\\paragraph{山东大学} is one of the best university in 山东。\r\\end{document}\r 在文档类 article/ctexart 中，定义了五个控制序列来调整行文组织结构。他们分别是\n \\section{·} \\subsection{·} \\subsubsection{·} \\paragraph{·} \\subparagraph{·}  插入目录 在上一节的文档中，找到 \\maketitle，在它的下面插入控制序列 \\tableofcontents，保存并用 XeLaTeX 编译两次。\n插入数学公式 在导言区加载 amsmath 宏包\n\\usepackage{amsmath}\r 数学模式 LaTeX 的数学模式有两种：行内模式 (inline) 和行间模式 (display)。\n在行文中，使用 $ ... $ 可以插入行内公式，使用 \\[ ... \\] 可以插入行间公式，如果需要对行间公式进行编号，则可以使用 equation 环境：\n\\begin{equation}\r...\r\\end{equation}\r 示例：\n\\documentclass{article}\r\\usepackage{amsmath}\r\\begin{document}\rEinstein 's $E=mc^2$.\r\\[ E=mc^2. \\]\r\\begin{equation}\rE=mc^2.\r\\end{equation}\r\\end{document}\r 行内公式和行间公式对标点的要求是不同的：行内公式的标点，应该放在数学模式的限定符之外，而行间公式则应该放在数学模式限定符之内。\n 上标：^ （注意花括号 {}的运用） 下标： _ 根式： \\sqrt{·} 分式： \\frac{·}{·} （第一个参数为分子，第二个为分母）  在行间公式和行内公式中，分式的输出效果是有差异的。如果要强制行内模式的分式显示为行间模式的大小，可以使用 \\dfrac, 反之可以使用 \\tfrac\n运算符 \\[ \\pm\\; \\times \\; \\div\\; \\cdot\\; \\cap\\; \\cup\\;\r\\geq\\; \\leq\\; \\neq\\; \\approx \\; \\equiv \\]\r 连加、连乘、极限、积分等大型运算符分别用 \\sum, \\prod, \\lim, \\int 生成。他们的上下标在行内公式中被压缩，以适应行高。我们可以用 \\limits 和 \\nolimits 来强制显式地指定是否压缩这些上下标。\n$ \\sum_{i=1}^n i\\quad \\prod_{i=1}^n $\r$ \\sum\\limits _{i=1}^n i\\quad \\prod\\limits _{i=1}^n $\r\\[ \\lim_{x\\to0}x^2 \\quad \\int_a^b x^2 dx \\]\r\\[ \\lim\\nolimits _{x\\to0}x^2\\quad \\int\\nolimits_a^b x^2 dx \\]\r 多重积分可以使用 \\iint, \\iiint, \\iiiint, \\idotsint 等命令输入。\n\\[ \\iint\\quad \\iiint\\quad \\iiiint\\quad \\idotsint \\]\r 定界符（括号等） 各种括号用 (), [], \\{\\}, \\langle\\rangle 等命令表示；注意花括号通常用来输入命令和环境的参数，所以在数学公式中它们前面要加 \\。因为 LaTeX 中 | 和 \\| 的应用过于随意，amsmath 宏包推荐用 \\lvert\\rvert 和 \\lVert\\rVert 取而代之。\n为了调整这些定界符的大小，amsmath 宏包推荐使用 \\big, \\Big, \\bigg, \\Bigg 等一系列命令放在上述括号前面调整大小。\n\\[ \\Biggl(\\biggl(\\Bigl(\\bigl((x)\\bigr)\\Bigr)\\biggr)\\Biggr) \\]\r\\[ \\Biggl[\\biggl[\\Bigl[\\bigl[[x]\\bigr]\\Bigr]\\biggr]\\Biggr] \\]\r\\[ \\Biggl \\{\\biggl \\{\\Bigl \\{\\bigl \\{\\{x\\}\\bigr \\}\\Bigr \\}\\biggr \\}\\Biggr\\} \\]\r\\[ \\Biggl\\langle\\biggl\\langle\\Bigl\\langle\\bigl\\langle\\langle x\r\\rangle\\bigr\\rangle\\Bigr\\rangle\\biggr\\rangle\\Biggr\\rangle \\]\r\\[ \\Biggl\\lvert\\biggl\\lvert\\Bigl\\lvert\\bigl\\lvert\\lvert x\r\\rvert\\bigr\\rvert\\Bigr\\rvert\\biggr\\rvert\\Biggr\\rvert \\]\r\\[ \\Biggl\\lVert\\biggl\\lVert\\Bigl\\lVert\\bigl\\lVert\\lVert x\r\\rVert\\bigr\\rVert\\Bigr\\rVert\\biggr\\rVert\\Biggr\\rVert \\]\r 省略号 省略号用 \\dots, \\cdots, \\vdots, \\ddots 等命令表示。\\dots 和 \\cdots 的纵向位置不同，前者一般用于有下标的序列。\n\\[ x_1,x_2,\\dots ,x_n\\quad 1,2,\\cdots ,n\\quad\r\\vdots\\quad \\ddots \\]\r 矩阵 amsmath 的 pmatrix, bmatrix, Bmatrix, vmatrix, Vmatrix 等环境可以在矩阵两边加上各种分隔符。\n\\[ \\begin{pmatrix} a\u0026amp;b\\\\c\u0026amp;d \\end{pmatrix} \\quad\r\\begin{bmatrix} a\u0026amp;b\\\\c\u0026amp;d \\end{bmatrix} \\quad\r\\begin{Bmatrix} a\u0026amp;b\\\\c\u0026amp;d \\end{Bmatrix} \\quad\r\\begin{vmatrix} a\u0026amp;b\\\\c\u0026amp;d \\end{vmatrix} \\quad\r\\begin{Vmatrix} a\u0026amp;b\\\\c\u0026amp;d \\end{Vmatrix} \\]\r 多行公式 长公式 不对齐 无须对齐的长公式可以使用 multline 环境。\n\\begin{multline}\rx = a+b+c+{} \\\\\rd+e+f+g\r\\end{multline}\r 如果不需要编号，可以使用 multline* 环境代替。\n对齐 需要对齐的公式，可以使用 aligned 次环境来实现，它必须包含在数学环境之内。\n\\[\\begin{aligned}\rx ={}\u0026amp; a+b+c+{} \\\\\r\u0026amp;d+e+f+g\r\\end{aligned}\\]\r 公式组 无需对齐的公式组可以使用 gather 环境，需要对齐的公式组可以使用 align 环境。他们都带有编号，如果不需要编号可以使用带星花的版本。\n分段函数 分段函数可以用cases次环境来实现，它必须包含在数学环境之内。\n\\[ y= \\begin{cases}\r-x,\\quad x\\leq 0 \\\\\rx,\\quad x\u0026gt;0\r\\end{cases} \\]\r 辅助工具：https://www.latexlive.com/\n插入图片和表格 图片 在 LaTeX 中插入图片，利用 graphicx 宏包提供的 \\includegraphics 命令。\n\\documentclass{article}\r\\usepackage{graphicx}\r\\begin{document}\r\\includegraphics{a.jpg}\r\\end{document}\r 用 \\includegraphics 控制序列的可选参数来控制图片输出效果：\n\\includegraphics[width = .8\\textwidth]{a.jpg}\r 图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。\n表格 tabular 环境提供了最简单的表格功能。它用 \\hline 命令表示横线，在列格式中用 | 表示竖线；用 \u0026amp; 来分列，用 \\\\ 来换行；每列可以采用居左、居中、居右等横向对齐方式，分别用 l、c、r 来表示。\n\\begin{tabular}{|l|c|r|}\r\\hline\r操作系统\u0026amp; 发行版\u0026amp; 编辑器\\\\\r\\hline\rWindows \u0026amp; MikTeX \u0026amp; TexMakerX \\\\\r\\hline\rUnix/Linux \u0026amp; teTeX \u0026amp; Kile \\\\\r\\hline\rMac OS \u0026amp; MacTeX \u0026amp; TeXShop \\\\\r\\hline\r通用\u0026amp; TeX Live \u0026amp; TeXworks \\\\\r\\hline\r\\end{tabular}\r 浮动体 见原文。。。\n版面设置 页边距 设置页边距，推荐使用 geometry 宏包。\n比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：\n\\usepackage{geometry}\r\\geometry{papersize={20cm,15cm}}\r\\geometry{left=1cm,right=2cm,top=3cm,bottom=4cm}\r 页眉页脚 设置页眉页脚，推荐使用 fancyhdr 宏包。\n比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：\n\\usepackage{fancyhdr}\r\\pagestyle{fancy}\r\\lhead{\\author}\r\\chead{\\date}\r\\rhead{152xxxxxxxx}\r\\lfoot{}\r\\cfoot{\\thepage}\r\\rfoot{}\r\\renewcommand{\\headrulewidth}{0.4pt}\r\\renewcommand{\\headwidth}{\\textwidth}\r\\renewcommand{\\footrulewidth}{0pt}\r 首行缩进 CTeX 宏集已经处理好了首行缩进的问题（自然段前空两格汉字宽度）。因此，使用 CTeX 宏集进行中西文混合排版时，我们不需要关注首行缩进的问题。\n行间距 我们可以通过 setspace 宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：\n\\usepackage{setspace}\r\\onehalfspacing\r 段间距 我们可以通过修改长度 \\parskip 的值来调整段间距。例如在导言区添加以下内容\n\\addtolength{\\parskip}{.4em}\r 则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。\n","date":1625285592,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1625285592,"objectID":"01aaf1b154bff07f4fce5e08adf6374d","permalink":"https://chen-gary.github.io/post/latex-basic/","publishdate":"2021-07-03T12:13:12+08:00","relpermalink":"/post/latex-basic/","section":"post","summary":"Tutorial Link: https://liam.page/2014/09/08/latex-introduction/","tags":["LaTeX"],"title":"LaTeX Basic","type":"post"},{"authors":["Gary Chen"],"categories":null,"content":"摘要 在Windows平台下安装、配置Hugo，并通过Github Pages部署个人博客\n前言 本来打算把这篇文章作为博客的第一篇post，结果拖了将近半年 ╥﹏╥\u0026hellip;\n写这篇文章一是为了给自己的博客留个纪念；二是梳理一下自己大体的博客搭建流程，方便后期debug甚至重构；三或许还能帮助到一些有缘人？\n听说百度的爬虫爬不到github.io域名的内容，再加上这种个人博客本身就做不到很好的SEO。以后的博文大概率也就是一名新手“码农”的“自嗨” ︿(￣︶￣)︿，不过能有一个整理自己笔记和想法的小空间也真是一件很开心的啊！希望能坚持下来！\n不多bb，准备开始！\n先决条件 我使用的工具：\n Git 2.30.0 Hugo v0.80.0 一个注册好的GitHub账号  前置知识：\n 了解最最基本的Git操作 对GitHub有一点点了解 会使用markdown编写文章 难度不大，但还是希望你有一颗勇于折腾的心  更新并配置Git git --version\t# check the version of git\rgit update-git-for-windows\t# update git to the latest version\r GitHub最近（当你看到这篇文章的时候已经不是最近了）把原先默认的master分支改名成了main，为了紧跟潮流，也为了满足自己的强迫症，这里选择更新git版本\n# 配置\rgit config --global user.name \u0026quot;\u0026lt;user_name\u0026gt;\u0026quot;\rgit config --global user.email \u0026lt;example\u0026gt;@gmail.com\rgit config --list\r 更多Git基础操作可以参考\r我的笔记。\n安装Hugo 相较于Mac和Linux，Hugo在Windows下的安装相对复杂。我们这里选择使用编译好的Windows可执行文件进行安装。安装路径我选择D盘的根目录，你也可以选择其他路径。\n  在D盘根目录下创建新文件夹Hugo，并在D:\\Hugo下新建文件夹bin和Sites\n D:\\Hugo\\bin将存放Hugo可执行文件 D:\\Hugo\\Sites将存放以后博客的git仓库    到\rHugo的GitHub仓库下载最新的Hugo二进制文件，我下载的是hugo_0.80.0_Windows-64bit.zip\n  解压下载好的压缩包至D:\\Hugo\\bin。现在你应该能看到D:\\Hugo\\bin中有三个文件hugo.exe, LICENSE及README.md。\n在D:\\Hugo\\bin下打开cmd，执行hugo version和hugo help应该能得到适当的反馈。但在其他路径下，这两条命令却无法正确执行，所以接下来我们要配置系统环境变量，使Hugo命令可以在任意路径下使用\n  为Hugo配置系统环境变量\n  搜索并打开Edit the system environment variables\n  点击Environment Variables\u0026hellip;\n  在User variables中双击Path\n  点击New，添加D:\\Hugo\\bin\n  验证环境变量是否配置成功\necho %PATH%\t# 确保能找到D:\\Hugo\\bin\rhugo version\t# 在任意路径下均可正确执行\r （注：配置完环境变量后，可能需要等一段时间才能正常使用Hugo命令）\n    恭喜！现在Hugo已经安装完成，接下来我们用它开始搭建自己的博客吧！\n搭建本地博客 初始化博客 在D:\\Hugo\\Sites下启动cmd，使用命令\nhugo new site \u0026lt;name\u0026gt;\r 由于我们将把本地博客部署到GitHub，这里我们把\u0026lt;name\u0026gt;换成\u0026lt;github_user_name\u0026gt;.github.io，比如我使用hugo new site Chen-Gary.github.io\n你会发现Hugo在D:\\Hugo\\Sites下创建了一个新文件夹Chen-Gary.github.io里面已经包含了一些文件\n下载主题 （如果没有特殊说明，所有命令都默认在博客的根目录下执行，即/d/Hugo/Sites/Chen-Gary.github.io）\n在\rHugo主题库找到一个你喜欢的主题，下面的步骤将以\rStack为例。下载主题本质就是git克隆，通常这些主题都会在README或\rDocumentation中提供克隆命令（也可以下载对应主题GitHub上的release版本，操作类似，请参考对应主题的Documentation）\ngit clone https://github.com/CaiJimmy/hugo-theme-stack/themes/hugo-theme-stack\r （注：如果采用下载release版本主题的方法，请忽视以下内容）\n克隆完成后，themes/hugo-theme-stack会是一个给git仓库，由于后期我们会将把博客的根目录Chen-Gary.github.io也变为git仓库，为避免仓库套仓库的情况，这里有两种解决策略：\n 删除themes/hugo-theme-stack中的，.git文件下把git仓库变成普通文件夹（我采取这个方案，因为后期我们可能大规模“定制”下载的主题，需要对主题内的文件进行版本控制；另外，还因为我不太搞得懂git submodule。。。） 使用git的submodule feature（不太推荐）  本地测试 使用以下命令测试。值得注意的是Stack主题有一些很坑爹的细节，搞了我很久。下一小节我会详说。\nhugo server -t \u0026lt;theme_name\u0026gt; --buildDrafts\r# example\rhugo server -t hugo-theme-stack --buildDrafts\r 根据命令行提示，在浏览器进入http://localhost:1313/预览博客效果。\n测试完成后，使用Ctrl + C结束server。\n修改配置文件 修改博客根目录下的config.toml或config.yaml。注意很多主题是会提供配置文件样板的，如果有请使用主题提供的配置文件。config.toml和config.yaml只需一个（也只能有一个），删除多余的配置文件。\n至少进行以下配置（以config.toml为例）：\nbaseURL = \u0026quot;https://\u0026lt;github_user_name\u0026gt;.github.io/\u0026quot;\rlanguageCode = \u0026quot;en-us\u0026quot;\rtitle = \u0026quot;Gary's Blog Site\u0026quot;\rtheme=\u0026quot;theme_name\u0026quot;\r 由于在配置文件中指定了主题，以后进行本地测试只需：\nhugo server\r baseURL相当重要，这里提前配置好，后文会进一步解释。\n*关于Stack主题 Stack是个相当好看的主题。事实上，这个主题是吸引我使用Hugo的原因之一，但是有一些小细节相当坑爹（对于新手来说）。\n在进行本地测试之前，执行以下操作：\n 复制\\themes\\hugo-theme-stack\\exampleSite的内容至博客根目录，部分原有的文件会被覆盖。 删除Hugo原先自动生成的config.toml，以后的配置我们会直接使用Stack主题提供的config.yaml。 删除\\content\\post\\rich-content。原因是这篇sample post里使用了推特短代码，这会导致Hugo无法生成网页。 更多个性化操作请参考Stack主题提供的config.yaml文件及\r它的官方文档。如果你愿意也可以修改主题的HTML文件等。。  至此，你已经拥有了自己的本地博客库，并预览了发布后的效果。接下来可以开始写博文了！\n本地发布博文 使用以下命令新建博文\nhugo new post/\u0026lt;article_name\u0026gt;.md # new blog/article\rhugo new post/\u0026lt;article_name\u0026gt;/index.md # new blog/article (recommended)\r 空白的博文会被生成在\\content\\post目录下。\n注意：\n  \u0026lt;article_name\u0026gt;使用连字符隔开单词 e.g. hugo new post/git-basic-skills/index.md\n  推荐使用hugo new post/\u0026lt;article_name\u0026gt;/index.md，这样文章中的图片可以放在\\content\\post\\\u0026lt;article_name\u0026gt;中\n  现在，你可以使用喜欢的markdown编辑器编写博文。完成后用hugo server命令进行本地测试。\n生成网页 有了前面的铺垫，生成网页相当简单，完整命令如下：\nhugo --theme=\u0026lt;theme_name\u0026gt; --baseUrl=\u0026quot;https://\u0026lt;user_name\u0026gt;.github.io\u0026quot; --buildDrafts\r# a folder `public` will be created\r# example\rhugo --theme=m10c --baseUrl=\u0026quot;https://Gary-Hh-Chen.github.io\u0026quot; --buildDrafts\r 由于theme及baseUrl已在配置文件 (config.yaml) 中设置好了，命名可以被简化为：\nhugo\r 就是这么简洁，网页会被生成在博客根目录的public文件夹中。\n部署博客至GitHub 以下方法由Hugo官方文档修改得来。不知道为什么，\r这部分的官方文档被简化了很多。之前的文档虽然有bug，但相当详细。好在我们可以在\r官方文档的GitHub仓库下载旧版文档。我参考的是\rv0.80.0版本的文档。\n我们借助GitHub Pages服务部署博客。\n这里，我们选择从GitHub仓库的gh-pages分支发布网页。除此之外，还可以：\n 从main分支直接发布网页 从main分支的docs文件夹发布网页  这里我们不讨论三种方法的优劣，具体优劣可以参考\r旧版官方文档。具体操作如下：\n（注：以下步骤只需操作一次）\n1. 建立仓库 在GitHub建立新的public repository（空仓库，不添加README等），仓库的名字必须为\u0026lt;github_user_name\u0026gt;.github.io，如Chen-Gary.github.io。\n2. 修改.gitignore 把public文件夹加入.gitignore，因为我们不需要把生成的网页推送到main分支。\necho \u0026quot;public\u0026quot; \u0026gt;\u0026gt; .gitignore\r 3. 链接本地仓库 在博客根目录下，使用以下命令建立git仓库并链接至远端：\ngit init\rgit remote add origin https://github.com/\u0026lt;user_name\u0026gt;/\u0026lt;user_name\u0026gt;.github.io.git\rgit add . git commit -m \u0026quot;first commit for my blog\u0026quot;\rgit push -u origin main\r 此时博客的源文件已被推送到远端仓库。\n4. 初始化gh-pages 分支 说实话，后面这几个分支操作我是不太懂的。。。不过，能用就行不是吗？\n You can now initialize your gh-pages branch as an empty [orphan branch][]:\n git checkout --orphan gh-pages\rgit reset --hard\rgit commit --allow-empty -m \u0026quot;Initializing gh-pages branch\u0026quot;\rgit push upstream gh-pages\rgit checkout main\r 5. 生成网页并部署  Now check out the gh-pages branch into your public folder using git\u0026rsquo;s [worktree feature][]. Essentially, the worktree allows you to have multiple branches of the same local repository to be checked out in different directories:\n rm -rf public\rgit worktree add -B gh-pages public upstream/gh-pages\rhugo\rcd public \u0026amp;\u0026amp; git add --all \u0026amp;\u0026amp; git commit -m \u0026quot;Publishing to gh-pages\u0026quot; \u0026amp;\u0026amp; cd ..\rgit push upstream gh-pages\r 6. 设置仓库 在刚刚建好的GitHub仓库页面进入 Settings \u0026gt; Pages \u0026gt; Source，进行以下设置：\n设置为从gh-pages分支发布网页。\n等上一小会，你的博客就部署成功了！你可以在 https://\u0026lt;github_user_name\u0026gt;.github.io/ 访问你的博客！\n但是，等等，每次更新博客都要进行这么多命令行操作吗？这也太麻烦了吧！好在我们可以写一个脚本，把部署需要的命令都写在脚本里，就不需要每次都敲这么多命令了。\n自动化更新博文 接下来我们将写一个.sh script帮助我们部署网页。\n在博客根目录下新建deploy_to_ghpages.sh，加入以下代码：\n（注：以下代码由Hugo官方文档的代码修改而来）\n#!/bin/sh\rif [ \u0026quot;`git status -s`\u0026quot; ]\rthen\recho \u0026quot;The working directory is dirty. Please commit any pending changes.\u0026quot;\rexit 1;\rfi\recho \u0026quot;Deleting old publication\u0026quot;\rrm -rf public\rmkdir public\rgit worktree prune\rrm -rf .git/worktrees/public/\recho \u0026quot;Checking out gh-pages branch into public\u0026quot;\rgit worktree add -B gh-pages public origin/gh-pages\recho \u0026quot;Removing existing files\u0026quot;\rrm -rf public/*\recho \u0026quot;Generating site\u0026quot;\rhugo\recho \u0026quot;Updating gh-pages branch\u0026quot;\rcd public \u0026amp;\u0026amp; git add --all \u0026amp;\u0026amp; git commit -m \u0026quot;Publishing to gh-pages (deploy_to_ghpages.sh)\u0026quot; \u0026amp;\u0026amp; cd ..\recho \u0026quot;Pushing to github\u0026quot;\r#git push --all # use this command or `git push origin gh-pages` should be both OK\rgit push origin gh-pages\r 这段代码大概做了：\n 检查仓库是否有未commit的修改，如有，则终止部署 如果仓库clean，则自动重新生成新的网页，并推送网页至gh-pages分支  将deploy_to_ghpages.sh commit 进仓库。\n至此所有准备工作都已就绪，你可以开始在自己的博客中发布文章了！如果你已经忘记了之前提到的一系列命令，没关系，下一节我会整理发布或更新博文所需的全部命令！\n总结 - 发布博文流程 如果你按照以上流程初始化好了你的博客，接下来想要更新文章会非常简单：\n（注：由于.sh文件需要在git bash中执行，以下命令默认都在git bash中执行）\ngit status\rhugo new post/\u0026lt;article_name\u0026gt;/index.md # new blog/article (recommended)\r# 编写博文...\rhugo server # local test (optional)\rgit add . git commit -m \u0026quot;add new post XXXX\u0026quot;\rgit push\r./deploy_to_ghpages.sh # deploy\r 同时，我们也梳理一下GitHub仓库的文件结构：\n main分支：博客的源文件，可以通过这些源文件生成网页。你需要在这个分支上，对博客源文件进行正常的版本控制。 gh-pages分支：由Hugo基于博客源文件生成的静态博客网页，是GitHub Pages生成网站所需的所有内容。这个分支纯由Hugo生成，无需对该分支的版本进行过多理会。  至此，借助Hugo和GitHub搭建个人博客的全部流程都结束啦！开始经营这个属于自己的小天地吧！\n附录 好看的主题   https://themes.gohugo.io/hugo-theme-stack/\nhttps://docs.stack.jimmycai.com/\n  https://themes.gohugo.io/loveit/\n  多语言支持 https://pzhao.org/zh/post/hugo-multilingual/\nhttps://gohugo.io/content-management/multilingual/\nhttps://regisphilibert.com/blog/2018/08/hugo-multilingual-part-1-managing-content-translation/\nSVG图下载 https://tablericons.com/\n","date":1622951297,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622951297,"objectID":"279471efe52f32f5b2f06908eec7447e","permalink":"https://chen-gary.github.io/post/building-blog-using-hugo/","publishdate":"2021-06-06T11:48:17+08:00","relpermalink":"/post/building-blog-using-hugo/","section":"post","summary":"在Windows平台下安装、配置Hugo，并通过Github Pages部署个人博客","tags":["Blog","Hugo"],"title":"Building Blog Using Hugo","type":"post"},{"authors":["Gary Chen"],"categories":null,"content":"配置 Configuration git config --global user.name \u0026quot;Your Name\u0026quot;\rgit config --global user.email \u0026quot;email@example.com\u0026quot;\rgit config --list\r 创建版本库 git init\rls -ah\r 基础命令 git add \u0026lt;file\u0026gt;\rgit commit -m \u0026lt;message\u0026gt;\rgit status\r 版本回退 git log\rgit log --pretty=oneline\r  HEAD 当前版本 HEAD^ 上一个版本 HEAD^^ 上上一个版本 HEAD~100  git reset --hard HEAD^\rgit log\r 回到未来的某个版本 git reset --hard \u0026lt;commit_id\u0026gt;\rgit reset --hard 1094a\rgit reflog # find commit id\r 撤销修改 注意：以下命令似乎是旧版git命令，虽然不影响使用，但建议参考git status的提示，使用新版命令。\n1. 丢弃工作区的修改 git checkout -- file\rgit checkout -- README.md\r 两种情况:\n  一种是README.md自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n  一种是README.md已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n  总之，就是让这个文件回到最近一次git commit或git add时的状态。\n2. 丢弃暂存区的修改 用命令git reset HEAD \u0026lt;file\u0026gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区\ngit reset HEAD README.md # 把暂存区的修改回退到工作区\r 接着，丢弃工作区的修改\u0026hellip;\n3. 丢弃commit 使用版本回退\n远程仓库 1. Github配置 (SSH)   创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。\nssh-keygen -t rsa -C \u0026quot;youremail@example.com\u0026quot;\r 一路回车\n id_rsa是私钥 id_rsa.pub是公钥    登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。\n  2. (将已有的本地仓库)添加远程库   在GitHub新建repo\n  把一个已有的本地仓库与之关联\n在本地的仓库下运行命令\ngit remote add origin git@github.com:XXXXXX/YYYYYY.git\r 添加后，远程库的名字就是origin (这是Git默认的叫法)\n  （首次）把本地库的所有内容推送到远程库上\ngit push -u origin main\r 注意：由于远程库是空的，我们第一次推送main分支时，加上了-u参数，Git不但会把本地的main分支内容推送的远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令。\n  （非首次）把本地库推送到远程库\ngit push origin main\r   注意：SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。\n3. 删除远程库 (解除本地和远程的绑定关系) 如果添加的时候地址写错了，或者就是想删除远程库，\n先用git remote -v查看远程库信息 (git remote 可查阅更简单的远程库的信息)\ngit remote -v\r 根据名字删除，比如删除origin\ngit remote rm origin\r 从远程库克隆 git clone git@github.com:XXXXX/YYYYY.git\r 分支管理   HEAD指向当前分支 e.g. main\n  main指向提交\n  1. 分支基础操作（创建与合并分支） 实战 (example)\n  创建dev分支，然后切换到dev分支\ngit checkout -b dev\r git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\ngit branch dev\rgit checkout dev\r   用git branch命令查看当前分支\ngit branch\r git branch命令会列出所有分支，当前分支前面会标一个*号。\n  切换回main分支\ngit checkout main\r   dev分支的工作成果合并到main分支上\ngit merge dev\r git merge命令用于合并指定分支到当前分支。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n  删除dev分支\ngit branch -d dev\rgit branch\r   注意：\n  创建并切换到新的dev分支，可以使用：\ngit switch -c dev\r   直接切换到已有的main分支，可以使用：\ngit switch main\r   分支基础操作总结：\n查看分支：git branch\n创建分支：git branch \u0026lt;name\u0026gt;\n切换分支：git checkout \u0026lt;name\u0026gt;或者git switch \u0026lt;name\u0026gt;\n创建+切换分支：git checkout -b \u0026lt;name\u0026gt;或者git switch -c \u0026lt;name\u0026gt;\n合并某分支到当前分支：git merge \u0026lt;name\u0026gt;\n删除分支：git branch -d \u0026lt;name\u0026gt;\n2. 解决冲突 main分支和feature1分支各自都分别有新的提交\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突\ngit merge feature1 # Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交\rgit status # 也可以告诉我们冲突的文件\r 注意：解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n直接查看README.md的内容:\nGit用\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;，=======，\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;标记出不同分支的内容\n手动解决冲突后再提交 =\u0026gt; 现在，master分支和feature1分支变成了下图所示：\n查看分支的合并情况：git log --graph --pretty=oneline --abbrev-commit\n最后，删除feature1分支：git branch -d feature1\n工作完成。\n3. 分支管理策略 (普通模式合并) 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\ngit merge --no-ff -m \u0026quot;merge with no-ff\u0026quot; dev\r 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n4. Bug分支 (stash功能) git stash\r# 去别的分支修bug\rgit stash list\r# method 1\rgit stash apply # 恢复，但是恢复后，stash内容并不删除\rgit stash drop # 删除stash内容\r# method 2\rgit stash pop # 恢复的同时把stash内容也删了 (recommended)\r 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\ngit stash apply stash@{0}\r Q: 如果在两个独立的分支上有同样的bug (e.g. main和dev上有同一bug)，且main上的bug已被修复，如何优雅地/简单地修复dev上的bug？\nA: 使用cherry-pick命令\n5. Feature分支 (强行删除未合并的分支) $ git branch -d feature-vulcan\rerror: The branch 'feature-vulcan' is not fully merged.\rIf you are sure you want to delete it, run 'git branch -D feature-vulcan'.\r# Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数\r$ git branch -D feature-vulcan\rDeleted branch feature-vulcan (was 287773e).\r 开发一个新feature，最好新建一个分支；\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D \u0026lt;name\u0026gt;强行删除。\n6. 多人协作 # 查看远程库的信息\rgit remote\rgit remote -v\r# 推送分支\rgit push origin master\rgit push origin dev\r# 不一定所有分支都要推送到远程，比如bug分支只要留在本地repo就行了\r 抓取分支 多人协作时，大家都会往master和dev分支上推送各自的修改。\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n(注意：在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致)\ngit checkout -b dev origin/dev\r# git pull #???拉取远端dev?\r 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送。\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。\ngit branch --set-upstream-to=origin/\u0026lt;branch_remote\u0026gt; \u0026lt;branch_local\u0026gt;\rgit branch --set-upstream-to=origin/dev dev\rgit pull\r 这回git pull成功，但是合并有冲突，需要手动解决。\n多人协作小结 多人协作的工作模式通常是这样：\n 首先，可以试图用git push origin \u0026lt;branch-name\u0026gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u0026lt;branch-name\u0026gt;推送就能成功！  如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to \u0026lt;branch-name\u0026gt; origin/\u0026lt;branch-name\u0026gt;。\n注意：可以克隆指定分支\ngit clone -b \u0026lt;branch\u0026gt; \u0026lt;remote_repo\u0026gt;\rgit clone -b BBBBBBB git@github.com:XXXXXX/YYYYYYY.git\r Rebase git rebase\r 我看不懂。。。\n标签管理 Git的标签：指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动）\ntag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起\n1. 创建标签 git checkout main\r# 默认标签是打在最新提交的commit上的\r# 1\rgit tag \u0026lt;name\u0026gt;\rgit tag v1.0\r# 2\rgit tag \u0026lt;tag_name\u0026gt; \u0026lt;commit_id\u0026gt;\rgit tag v0.9 f52c633\r# 3 创建带有说明的标签\rgit tag -a \u0026lt;tag_name\u0026gt; -m \u0026quot;blablabla...\u0026quot;\rgit tag -a v0.1 -m \u0026quot;version 0.1 released\u0026quot; 1094adb\rgit tag # 查看所有标签\rgit show \u0026lt;tagname\u0026gt; # 查看标签信息\r 2. 操作标签 删除标签\ngit tag -d v0.1\r 创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，\ngit push origin \u0026lt;tag_name\u0026gt;\rgit push origin v1.0\r# 一次性推送全部尚未推送到远程的本地标签\rgit push origin --tags\r 如果标签已经推送到远程，要删除远程标签就麻烦一点：\n# 先从本地删除\rgit tag -d v0.9\r# 然后，从远程删除\rgit push origin :refs/tags/v0.9\r 其他命令 不常用的基础命令\n  查看修改\ngit diff\rgit diff README.md\r   删除文件\ngit rm \u0026lt;file\u0026gt; # 与`git add\u0026lt;file\u0026gt;`效果一样\r   强制添加被ignore的文件\ngit add -f \u0026lt;file_name\u0026gt;\r   检查.gitignore对于某个文件的规则\ngit check-ignore -v \u0026lt;file_name\u0026gt;\r Git会告诉我们，.gitignore的第X行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。\n  配置别名\n# e.g. 让st表示status\rgit config --global alias.st status\r 或直接在git的全局/某个repo的config文件中配置\n  ","date":1622337077,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622337077,"objectID":"aaff08ebf710130612cf9226cbf16bc4","permalink":"https://chen-gary.github.io/post/git-basic-skills/","publishdate":"2021-05-30T09:11:17+08:00","relpermalink":"/post/git-basic-skills/","section":"post","summary":"Tutorial Link: https://www.liaoxuefeng.com/wiki/896043488029600","tags":["Git"],"title":"Git Basic Skills","type":"post"},{"authors":["Gary Chen"],"categories":["Blender"],"content":"View: Numpad 1 / 3 / 7, or ctrl + Numpad 1 / 3 / 7\nE to extrude\n alt + E  face normal\n I to insert\n double lick I\nB while doing insert (if B does not work, press I again to disable individual faces) (e.g. car window)\n G\nS\nR\nO proportional editing (when modeling the tree)\nctrl + B Bevel\nalt + S shrink / flatten\nshift + right click place 3D curser\n shift + S \u0026gt; Cursor to selected\nshift + C re-center 3D curser\n L select linked (in edit mode)\n shift + L to deselect linked\n Selection Method L\nLoop select: alt + click on edge (in face selection mode)\ncircle select: C\n deselect: middle mouse\n ring select: alt + ctrl (in edge select mode)\nLoop select: alt + click on edge (in edge selection mode)\nselect shortest path: ctrl (in edge select mode)\nbox select: B (in vertex select mode)\nalt + Z enable/disable X-ray (to select the back vertices)\nLasso select (套索): ctrl + right mouse button\nGrow selection (select all faces neighboring to the selected face): ctrl + Numpad plus +\n Shrink selection (opposite to grow selection): ctrl + -\n select random\nselect similar: shift + G\nchecker deselect (间隔选中效果，像足球那样): F\nH hide selected objects\n alt + H unhide all\n ctrl + I: Invert selection (选中所有未被当前选中的东西)\n Loop cut: ctrl + R\nKnife tool: K\n ctrl: snap to center with knife tool\nC: angle constraint with knife tool\n ctrl + 1-5: subdivision modifier (remember to apply this modifier)\n if it make the object not low-poly, then use Decimate modifier to make it back to low-poly.\n(see video around 48:00)\n ,: Orientation\nsnap (上方的磁贴icon) (hotkey: ctrl when using G) \u0026mdash;-\u0026gt; 把两个vertices连在一起 (注意：这样snap后，实际上仍然是两个vertices) \u0026mdash;\u0026mdash;\u0026gt; two solutions\n  use snap along with Auto Merge Vertices after snap, A to select all, then M to merge merge by distance    snap along an axis, instead of snap two vertices, to align\n after delete some faces, use F to Fill / Create face(s) (自动填补holes)\n  select the whole object and F select certain edges and F   after selecting 2 vertices, press J / F to add an edge between these 2 vertices (J will make the object more low-poly, while F simply add an edge without affecting the original shape)\nBesides J, we can use ctrl + T to Triangulate selection to make a round face more low-poly after using F to Fill a hole\nsetting: enable Backface Culling\nF3 search flip normal (or alt + N)\nsome faces are flipped, to fix it alt + N \u0026gt; recalculate outside\nX dissolve edges\nTo connect two meshes inside one object into one single mesh, select two faces which you want to connect and F3 \u0026gt; Bridge Edge Loops\ntips: shift + D to duplicate a face, right mouse to put the new face exactly the same location as the original one\nSeparate selection to new object: P\nMerge into a single object: ctrl + J\nModifiers Mirror modifier (use auto mirror add-on)\nSubdivision surface modifier: ctrl + 5 or other (subdivide a plane to create low-poly island)\nDisplace modifier (low-poly landscape)\nSkin modifier (use with extra mesh add-on, so that we can add single vertex, and then build a low-poly tree)\n A to select all, and then ctrl + A to scale\n  Tips If we scare the object outside edit mode, ctrl + A \u0026gt; apply scale to make the scare 1, 1, 1 again!\nNumpad .: to make viewport rotate around selection\n","date":1614761314,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1614761314,"objectID":"bdc8ac9c78505b6dcae8b15107368f69","permalink":"https://chen-gary.github.io/post/blender-tutorial-notes/","publishdate":"2021-03-03T16:48:34+08:00","relpermalink":"/post/blender-tutorial-notes/","section":"post","summary":"Tutorial Link: https://www.youtube.com/watch?v=1jHUY3qoBu8","tags":["Blender"],"title":"Blender Tutorial Notes","type":"post"},{"authors":["Gary Chen"],"categories":null,"content":"在使用CLion编写C++项目后，IDE会自动生成CMakeLists.txt文件。那么如何手动编译我们写的代码呢？\n步骤如下\n  将项目中的所有源文件 + 自动生成的CMakeLists.txt 传入Linux虚拟机（的同一目录下）\n  mkdir build\rcd build\rcmake ..\t# 用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件\rmake\t# 用make命令编译源码生成可执行程序\r   运行\n./name_of_executable\r   (ref: https://www.cnblogs.com/cv-pr/p/6206921.html)\n","date":1614758066,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1614758066,"objectID":"76a276bd3a9846ee72f82ed5abcf915a","permalink":"https://chen-gary.github.io/post/compile-using-cmake/","publishdate":"2021-03-03T15:54:26+08:00","relpermalink":"/post/compile-using-cmake/","section":"post","summary":"使用CMake进行编译","tags":["CMake","C++"],"title":"Compile Using CMake","type":"post"},{"authors":["Gary Chen"],"categories":["Blender"],"content":"使用material library的原因 多人合作时，方便颜色统一（尤其针对统一玻璃之类的复杂材质）\n如何导入material  打开想要导入material的 blender file 导航栏选择 File \u0026gt; Append 找到material_template_lib.blend，并双击进入 进入Material文件夹，并双击选择想导入的material  这样在Material selector中应该就能找到刚刚导入的material\n（注意重命名导入的material）\n（ref https://blender.stackexchange.com/questions/63018/how-to-import-downloaded-materials-files/63055）\n*合作方式 比如我负责选定玻璃的材质，那么我就\n 下载最新的material_template_lib.blend 新建一个cube，后新建并附上调好的玻璃材质 commit回GitHub，更新material_template_lib.blend  ","date":1613653049,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613653049,"objectID":"5bdde324c067cea98d34289ca918ae06","permalink":"https://chen-gary.github.io/post/blender-import-material-and-setup-material-library/","publishdate":"2021-02-18T20:57:29+08:00","relpermalink":"/post/blender-import-material-and-setup-material-library/","section":"post","summary":"Blender导入material，并建立material library","tags":["Blender"],"title":"Blender Import Material and Setup Material Library","type":"post"},{"authors":["Gary Chen"],"categories":["Blender"],"content":"The palette style UV coloring method 是一个使用调色板图片(palette) 对模型涂色的方法\n 优点：涂色非常简单快速，可以边建模边涂色（辅助建模） 缺点：有的时候不好找想要的颜色；多人合作时不方便后期统一颜色；导入unity时需要更改几个默认设置  为解决这些问题，我找到了一个快速对 UV coloring 的模型用标准 material 重新上色的方法。总的效率可能比建完整个模型再上色更高。\nThe palette style UV coloring method 这个方法来自于一名油管大佬 https://www.youtube.com/watch?v=1jHUY3qoBu8\n他在这个视频的 02:12 - 4:42 介绍了这个涂色方法\n这个视频的简介里，他给了两个 palette 的图片：\n  \r图一\n  \r图二\n  以及一个我觉得蛮不错的blender setting视频（这个很短的视频里也介绍了 The palette style UV coloring method 的方法）：\n\rhttps://www.youtube.com/watch?v=BlxiCd0Upg4\n用标准 material 重新上色 假设在建模的时候，我把墙面涂成了诡异的蓝色，而右边material栏中的 Material_final 是最终统一的墙面颜色。\n  tab 进入编辑模式\n  鼠标放在中间的编辑窗口，按 A 全选\n  点亮左侧 UV editor 窗口的这个icon (红色框框)\n  左键框选诡异的蓝色，这样中间窗口中所有使用这种蓝色的面就被选中了\n  这时候在右侧material栏更换material，并点击Assign，墙面就重新上色完成\n  同理，我们也可以对其他面重新上色\n这样直接把.blend 文件拖入unity 也可以保持所有颜色，无需任何设置。\n","date":1613651298,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613651298,"objectID":"306b5c5b4362a570b03c9d866193be5d","permalink":"https://chen-gary.github.io/post/blender-uv-coloring-method/","publishdate":"2021-02-18T20:28:18+08:00","relpermalink":"/post/blender-uv-coloring-method/","section":"post","summary":"使用调色板图片(palette)对模型涂色","tags":["Blender"],"title":"Blender UV Coloring Method","type":"post"},{"authors":null,"categories":null,"content":"","date":1601510400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601510400,"objectID":"31e0aab5b7c6b9c7a214e704f8aa4535","permalink":"https://chen-gary.github.io/project/game-enclosure/","publishdate":"2020-10-01T00:00:00Z","relpermalink":"/project/game-enclosure/","section":"project","summary":"This is a game development project, involving four members.","tags":["Game Development","Unity"],"title":"Enclosure","type":"project"}]